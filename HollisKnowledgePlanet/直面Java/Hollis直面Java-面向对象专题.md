## Hollis直面Java
### 《面向对象专题》
#### 1. *什么是面向对象，什么是面向过程，面向对象的三大基本特征和五大基本原则是什么？*
答：**面向过程**:将问题分解成一个一个的步骤，每个步骤用函数实现，依次调用即可。就是说，在进行面向过程编程中，不需要考虑其他的，上来就定义一个函数，然后使用if-else。for-each等方式进行代码执行。最典型的用法就是实现一个简单的算法，比如冒泡排序。

　　**面向对象**:将问题分解成一个一个的步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。就是说，在进行面向对象编程的过程中，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。比如想造一辆车，上来想把车的各种属性定义出来，然后抽象成一个car类。

　　**面向对象的三大基本特征**:封装、继承、多态；

　　[**面向对象五大基本原则**](https://github.com/UnchainMyHeart/JavaStudy/blob/master/HollisKnowledgePlanet/%E7%9B%B4%E9%9D%A2Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99.md):单一职责原则（Single-Responsibility Principle）、开放封闭原则（Open-Closed Principle）、Liskov替换原则（Liskov-Substitution Principle）、依赖倒置原则（Dependency-Inversion Principle）、接口隔离原则（Interface-Segregation Principle）。

#### 2.*Java和C++同为面向对象语言，Java和C++主要区别有哪些？双方个有哪些优缺点？*

答：C++ 被设计成主要用在系统性应用程序设计上的语言，对C语言进行了扩展。对于C语言这个为运行效率设计的过程式设计语言，C++特别加上了以下这些特性的支持:静态类型的面向对象程序设计的支持、异常处理、RAII以及泛型。另外它还加上了一个包含泛型容器和算法的C++库函数。

　　Java 最开始是被设计用来支持网络计算。它依赖一个虚拟机来保证安全和可移植性。Java包含一个可扩展的库用以提供一个完整的下层平台的抽象。Java是一种静态面向对象语言，它使用的语法类似C++，但与之不兼容。

　　C++是编译型语言（首先将源代码编译生成机器语言，再由机器运行机器码），执行速度快、效率高；依赖编译器，跨平台性差。

　　Java是解释性语言（源代码不是直接翻译成机器语言，而是先翻译成中间代码，再由解释器对中间代码进行解释运行），执行速度慢、效率低；依赖解释器、跨平台性好。

　　二者更多的主要区别如下:

- C++是平台相关的，Java是平台无关的；
- C++对所有的数字类型有标准的范围限制，但字节长度是跟具体实现相关的，不同操作系统可以不同。Java在所有平台上对所有的基本类型都有标准的范围限制和字节长度；
- C++允许直接调用本地的系统库。Java要通过JNI（[Java Native Interface](https://baike.baidu.com/item/JNI/9412164?fr=aladdin)）调用，或者JNA（[Java Native Access](https://baike.baidu.com/item/JNA/8637274?fr=aladdin)）；
- C++允许过程式程序设计和面向对象程序设计。Java必须使用面向对象的程序设计方式；
- C++支持指针，引用，传值调用；Java只有值传递；
- C++需要显式的内存管理，但有第三方的框架可以提供垃圾收集的支持。支持[析构函数](https://msdn.microsoft.com/zh-cn/magazine/6t4fe76c.aspx)。
- Java是自动垃圾收集的。没有析构函数的概念；
- C++支持多重继承，包括[虚拟继承](https://baike.baidu.com/item/%E8%99%9A%E7%BB%A7%E6%89%BF/2149276?fr=aladdin)。Java只允许单继承，需要多继承的情况要使用接口。

#### 3.*什么是平台无关性，Java是如何做到平台无关的？*

答：跨平台指的是一种语言在计算机上的运行不受平台的约束，一次编译到处执行。平台无关有两种:源代码和目标代码级。

　　一般说的跨平台或者平台无关，指的是目标代码，或者说是软件交付件跨平台。

　　C和C++要在在不同的平台运行，需要对源代码重新编译；Java编译出来的是字节码文件（.class），去哪个平台都能用，只要有那个平台的JDK就可以运行。.class文件+对应平台的JVM实现了Java的跨平台。

#### 4.*什么是值传递，什么是引用传递？为什么说Java只有值传递？*

答：[为什么说Java中只有值传递?](https://mp.weixin.qq.com/s/F7Niaa7nD1tLApCEGKAj4A)

　　**值传递（pass by value）**:指在调用函数时将实际参数**复制**一份传递到函数中，这样在函数中如果对参	数进行修改，将不会影响到实际参数。

　　**引用传递（pass by reference）**:指在调用函数时将实际参数的地址**直接**传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。

|          | 值传递                     | 引用传递                   |
| -------- | -------------------------- | -------------------------- |
| 根本区别 | 会创建副本（Copy）         | 不创建副本                 |
| 所以     | 函数中**无法改变**原始对象 | 函数中**可以改变**原始对象 |

　　在Java中当调用参数为对象的方法时，**把实参对象引用的地址当做值传递给了形式参数**。所以通过以下方式修改参数的值时，修改的是**地址指向的对象**，而不是地址，**地址未变**。

```java
   public static void main(String[] args) {
      ParamTest pt = new ParamTest();
      User hollis = new User();
      hollis.setName("Hollis");
      hollis.setGender("Male");
      pt.pass(hollis);
      System.out.println("print in main , user is " + hollis);
   }

   public void pass(User user) {
      user.setName("hollischuang");
      System.out.println("print in pass , user is " + user);
   }
   //结果
   print in pass , user is User{name='hollischuang', gender='Male'}
   print in main , user is User{name='hollischuang', gender='Male'}
```

　　**按共享传递**:是指在调用函数时，传递给函数的是实参的地址的拷贝（如果实参在栈中，则直接拷贝该值）。在函数内部对参数进行操作时，需要先拷贝的地址寻找到具体的值，再进行操作。如果该值在栈中，那么因为是直接拷贝的值，所以函数内部对参数进行操作不会对外部变量产生影响。如果原来拷贝的是原值在堆中的地址，那么需要先根据该地址找到堆中对应的位置，再进行操作。因为传递的是地址的拷贝所以函数内对值的操作对外部变量是可见的。

　　**按共享传递是按值传递的一个特例**，Java中的参数传递严格意义上说应该是按共享传递。

#### 5．*什么是编译，什么是反编译？Java的编译和反编译方法？*

答：**编译**:将高级语言转换为低级语言的过程，将便于人编写、阅读、维护的高级计算机语言所写作的源代码程序，翻译成计算机能解读、运行的低阶机器语言的程序的过程。

　　**反编译**:与编译相反，将已编译好的编程语言还原到未编译状态。

　　Java中复制编译的编译器是一个命令:javac

#### 6.*什么是Java的语法糖，列举你知道的语法糖，如何解语法糖？*

答：[语法糖](https://en.wikipedia.org/wiki/Syntactic_sugar):指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。

　　Java中常用的语法糖主要有:泛型、变长参数、条件编译、自动拆装箱，内部类等。

　　Java虚拟机并不支持这些语法糖，会在编译阶段将其还原成基础语法结构，这个过程就是**解语法糖**。

　　**switch**: 对于编译器来说，switch中其实只能使用整型，任何类型的比较都要转为整型；比如 char是比较其ASCII码，String 比较的是其hashCode，再通过equals()方法比较进行安全检查（哈希可能发生碰撞）。

　　**泛型**:对于Java虚拟机来说，它根本不认识类似Map<String,String> map这样的语法，需要在编译阶段通过类型擦除的方式进行解语法糖，结果为Map map。

　　**自动装箱与拆箱**:自动装箱就是Java自动将原始类型值转换为对应的对象，比如将int的变量转换为Integer对象，这个过程叫装箱；反之将Integer对象转换为int类型值，这个过程叫拆箱。装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的xxxValue方法实现的。

　　**方法变长参数**:可变参数在被使用的时候，它首先会创建一个数组，数组的长度就是调用该方法时传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。

　　**枚举**:通过反编译枚举我们可以发现public final class T extends Enum，说明该类继承了Enum类，同时final关键字告诉我们，这个类也是不能被继承的，当我们使用enum来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类，所以枚举类型不能被继承。

　　**内部类**:内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念，outer.java里面定义了一个内部类inner，一旦编译成功，就会生成两个完全不同的.class文件，分别是outer.class和outer$inner.class。所以内部类的名字完全可以和它的外部类名字相同。

#### 7.*Java8 中的lambda表达式是不是语法糖，具体如何实现的？*

答：Lambda表达式是语法糖，但不是匿名内部类的语法糖，实现方式其实是依赖了几个JVM底层提供的lambda相关api。在编译阶段，编译器会把lambda表达式进行解耦，转换成调用内部api的方式。

#### 8.*什么是多态，多态有什么好处，多态的必要条件是什么、Java中多态的实现方式？*

答：**多态**:同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。

　　**3个必要条件**:有类继承或接口实现、子类要重写父类的方法、父类的引用指向子类的对象；

#### 9.*什么是方法重写，什么是方法重载，成员变量可以被重写吗？*

答：**重载**:函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或方法之间，互相称之为重载函数或者方法。

　　**重写**:在子类和父类有两个名称、参数列表都相同的方法的情况下，由于它们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。

- 重载是一个编译期概念、重写是一个运行期间概念。
- 重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。
- 重写遵循所谓“运行期绑定”，即在运行时根据引用变量所指向的实际对象的类型来调用方法。
- 因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象无关。（注:严格来说，重载是编译时多态，及静态多态。但是，Java中提到的多态一般都指动态多态。）

　　正是因为Java在继承中有方法的重写，所以这也体现了Java的动态多态性。

　　重写指的是方法，并没有提到成员变量，成员变量不会被重写。

　　在一个类中，子类中的成员变量如果和父类中的成员变量同名，那么即使它们类型不一样，只要名字一样，父类中的成员变量都会被隐藏。在子类中父类的成员变量不能被简单的用引用的访问。而是必须从父类的引用获得父类被隐藏的成员变量。

　　参考:[深入理解Java中的重写和重载-HollisChuang's Blog](http://www.hollischuang.com/archives/1308)、 [Java中方法的重写与成员变量的隐藏-HollisChuang's Blog](http://www.hollischuang.com/archives/1871)

#### 10.*接口和抽象类的区别，如何选择？*

答：接口和抽象类最明显的区别就是接口只是定义了一些方法而已，在不考虑Java8的default方法情况下，接口中是没有实现的代码的。

　　抽象类中的抽象方法可以有public、protected 和default这些修饰符，而接口中默认修饰符是public。不可以使用其它修饰符。

　　关于如何选择，我们一般会把接口暴露给外部，然后再业务代码中实现接口。如果多个实现类中有相同可复用的代码，则在接口和实现类中加一层抽象类，将公用部分代码抽出到抽象类中。可参考**模板方法模式**。

#### 11.*Java能不能多继承，可不可以多实现？*

答：Java中不能多继承，可以多实现。即定义一个类的时候，可以同时实现多个接口，但是不能同时继承多个类。

#### 12.*什么是构造函数，什么是默认构造函数？*

答：**构造函数**，是一种特殊的方法。主要用来在创建对象时初始化对象，即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。特别的一个类可以有多个构造函数，可根据其参数个数的不同或者参数类型的不同来区分它们，即构造函数的重载。

　　如果在编写一个可实例化的类时没有专门编写构造函数，多数编程语言会自动生成**缺省构造器（默认构造函数）**。默认构造函数一般会把成员变量的值初始化为默认值，如int->0、Integer->null.

　　构造函数跟一般的实例方法十分相似；但是与其它方法不同，构造器没有返回类型，不会被继承，且可以有范围修饰符。构造器的函数名称必须和它所属的类的名称相同。它承担着初始化对象数据成员的任务。

#### 13.*构造方法能不能被重载，能不能被重写？*

答：构造方法可以被重载，实现对对象数据不同的初始化；不能被重写，子类不能继承父类的构造方法，只能在子类的构造方法中调用父类的构造方法（自动调用父类默认构造方法，或调用父类指定的构造方法），保证父类对象也进行初始化（子类继承父类对象的数据得到初始化）。

　　**实例化子类时，子类和父类初始化顺序:**

> 1，在类加载的时候执行父类的static代码块，并且只执行一次（因为类只加载一次）；
>
> 2，执行子类的static代码块，并且只执行一次（因为类只加载一次）；
>
> 3，执行父类的类成员初始化，并且是从上往下按出现顺序执行；
>
> 4，执行父类的构造函数；
>
> 5，执行子类的类成员初始化，并且是从上往下按出现顺序执行；
>
> 6，执行子类的构造函数。

#### 14.*对于成员变量和方法的作用域，public、protected、private，以及default的区别？*

答：

- public：表明该成员变量或者方法是对所有类或者对象都是可见的所有类或者对象都可以直接访问。
- protected：表明该成员变量或者方法对类自身，以同一包中的其他类可见，其他包下的类不可访问，除非是它的子类。
- default：表明该成员变量或者方法只能自己或者位于同一包的内可见，其他包内的类都不可见，即使是它的子类。
- private：表明该成员变量或者方法是私有的，只有当前类对其具有访问权限，其他类或者对象都没有访问权限，即使是它的子类。

| 作用域，可见性 | 当前类 | 同一包 | 子类 | 其他包 |
| -------------- | ------ | ------ | ---- | ------ |
| public         | Y      | Y      | Y    | Y      |
| protected      | Y      | Y      | N    | N      |
| default        | Y      | Y      | N    | N      |
| private        | Y      | N      | N    | N      |

#### 15.*接口能否继承接口？抽象类能否实现接口？抽象类能否继承具体类？*

答：接口可以继承接口，抽象类可以实现接口，抽象类也可以继承具体类。
